% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kafka_consumer_class.R
\name{kafka_consumer_class}
\alias{kafka_consumer_class}
\title{R6 Class for Kafka Consumer}
\description{
R6 Class for Kafka Consumer

R6 Class for Kafka Consumer
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{java_consumer}}{reference to the underlying Java object
Initialize}

\item{\code{records}}{If poll() did fetch any messages, they are stored here until the
next call to poll().

Note: Consider using consume methods instead of managing records on your own.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{kafka_consumer_class$new()}}
\item \href{#method-finalize}{\code{kafka_consumer_class$finalize()}}
\item \href{#method-start}{\code{kafka_consumer_class$start()}}
\item \href{#method-end}{\code{kafka_consumer_class$end()}}
\item \href{#method-running}{\code{kafka_consumer_class$running()}}
\item \href{#method-poll}{\code{kafka_consumer_class$poll()}}
\item \href{#method-commit}{\code{kafka_consumer_class$commit()}}
\item \href{#method-consume_next}{\code{kafka_consumer_class$consume_next()}}
\item \href{#method-consume_loop}{\code{kafka_consumer_class$consume_loop()}}
\item \href{#method-props}{\code{kafka_consumer_class$props()}}
\item \href{#method-topics_subscribe}{\code{kafka_consumer_class$topics_subscribe()}}
\item \href{#method-topics_subscription}{\code{kafka_consumer_class$topics_subscription()}}
\item \href{#method-topics_list}{\code{kafka_consumer_class$topics_list()}}
\item \href{#method-topics_seek_to_beginning}{\code{kafka_consumer_class$topics_seek_to_beginning()}}
\item \href{#method-topics_seek_to_end}{\code{kafka_consumer_class$topics_seek_to_end()}}
\item \href{#method-topics_offsets}{\code{kafka_consumer_class$topics_offsets()}}
\item \href{#method-clone}{\code{kafka_consumer_class$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new consumer object.
Instead of \code{kafka_class_consumer$new()} one can use \code{kafka_consumer()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$new()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{self} for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-finalize"></a>}}
\if{latex}{\out{\hypertarget{method-finalize}{}}}
\subsection{Method \code{finalize()}}{
Code run when object is removed from session
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$finalize()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-start"></a>}}
\if{latex}{\out{\hypertarget{method-start}{}}}
\subsection{Method \code{start()}}{
Spin up consumer and connect it to Kafka cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$start()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{self} for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-end"></a>}}
\if{latex}{\out{\hypertarget{method-end}{}}}
\subsection{Method \code{end()}}{
Disconnect consumer from Kafka cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$end()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{self} for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-running"></a>}}
\if{latex}{\out{\hypertarget{method-running}{}}}
\subsection{Method \code{running()}}{
Whether or not consumer is active (has been started or not)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$running()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
TRUE/FALSE
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-poll"></a>}}
\if{latex}{\out{\hypertarget{method-poll}{}}}
\subsection{Method \code{poll()}}{
Polling for messages
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$poll(timeout_ms = Inf)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{timeout_ms}}{number of miliseconds to wait for polling to return
messages, defaults to Inf}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the number of records retrieved by last poll
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-commit"></a>}}
\if{latex}{\out{\hypertarget{method-commit}{}}}
\subsection{Method \code{commit()}}{
Commit offsets returned on the last poll() for all the subscribed
list of topics and partitions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$commit(sync = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{sync}}{synchronous or asynchronous commit}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{self} for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-consume_next"></a>}}
\if{latex}{\out{\hypertarget{method-consume_next}{}}}
\subsection{Method \code{consume_next()}}{
Consume one message either from the records already fetched from last poll or via initiating a new poll.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$consume_next(timeout_ms = Inf)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{timeout_ms}}{defaults to `Inf`.
Time for which poll will wait for data
Passed through to kafka_consumer$poll()}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-consume_loop"></a>}}
\if{latex}{\out{\hypertarget{method-consume_loop}{}}}
\subsection{Method \code{consume_loop()}}{
Method that is basically an infinite loop (until the check expression
evaluates to FALSE) that will evaluate the supplied expression for
each loop.

There are several objects available to the expression supplied:

- messages: a data.frame/data.table with one or more rows - see batch parameter
- loop_counter: single number equal the current loop count.
- message_counter: single number equal to the number of messages already processed.
- start_time: the result of a call to Sys.time() when first the method started
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$consume_loop(
  f = function(loop_env) {     print(loop_env$messages) },
  check = function(loop_env) {     loop_env$meta$loop_counter < 1 },
  loop_env = new.env(),
  batch = FALSE,
  timeout_ms = Inf
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{check}}{expression (e.g. via \code{expression(...)}) that will
evaluate to TRUE or FALSE to either further process messages or
stop processing and ask function to return}

\item{\code{batch}}{defaults to FALSE, Kafka's the default is to poll for as much
data as one can get given the consumers limits on the number and
size of messages as well as the chosen timeout. No matter how many
data is returned from a poll the method process - if batch is set to
FALSE - return only a single message at a time. If batch is set to
TRUE however the msgs data.frame/data.table will contain all messages
that were retrieved by the last poll unless consumed already.}

\item{\code{timeout_ms}}{defaults to `Inf`.
Time for which poll will wait for data
Passed through to kafka_consumer$poll()}

\item{\code{expr}}{expression (e.g. via \code{expression(...)}) that will
process a single message}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-props"></a>}}
\if{latex}{\out{\hypertarget{method-props}{}}}
\subsection{Method \code{props()}}{
Retrieving current current set of properties.
If properties are supplied via props parameter thos properties will
be set.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$props(..., .properties = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{a series of properties provided as \code{key = "values"}}

\item{\code{.properties}}{a list of properties provided as  \code{.properties = list(key = "values", ...)}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns a list of properties
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_subscribe"></a>}}
\if{latex}{\out{\hypertarget{method-topics_subscribe}{}}}
\subsection{Method \code{topics_subscribe()}}{
Subscribe to one or more topics
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$topics_subscribe(topics)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{topics}}{character vector defining topics or topic regex to subscribe to}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{self} for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_subscription"></a>}}
\if{latex}{\out{\hypertarget{method-topics_subscription}{}}}
\subsection{Method \code{topics_subscription()}}{
List current subscription
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$topics_subscription()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_list"></a>}}
\if{latex}{\out{\hypertarget{method-topics_list}{}}}
\subsection{Method \code{topics_list()}}{
List topics available to consumer
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$topics_list(full = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{full}}{defaults to FALSE, whether or not to return all data
returned fro Java object (TRUE) or only a simple character vector
listing the names of the data topics available for consumption
(FALSE)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_seek_to_beginning"></a>}}
\if{latex}{\out{\hypertarget{method-topics_seek_to_beginning}{}}}
\subsection{Method \code{topics_seek_to_beginning()}}{
Seek to beginning of all topics subscribed and all partitions
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$topics_seek_to_beginning()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_seek_to_end"></a>}}
\if{latex}{\out{\hypertarget{method-topics_seek_to_end}{}}}
\subsection{Method \code{topics_seek_to_end()}}{
Seek to end of all topics subscribed and all partitions
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$topics_seek_to_end()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_offsets"></a>}}
\if{latex}{\out{\hypertarget{method-topics_offsets}{}}}
\subsection{Method \code{topics_offsets()}}{

\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$topics_offsets()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_consumer_class$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
